## 不同进程的表单、文件描述符、文件描述符空间

- 每个进程有独立的文件描述符空间和对应的表单
- 文件描述符空间里存储文件描述符
- 内核会为每一个运行进程保存一个表单，表单的key是文件描述符，表单的value是该文件描述符所指向的文件或资源
  - 当一个进程访问一个文件描述符时，内核会查看这个表单，找到与这个文件描述符对应的value，然后根据这个value来操作相应的文件或资源

> 所以：
>
> 尽管**两个不同的进程**可能有**相同的文件描述符**数字（例如，都有一个描述符“3”），但由于他们的文件描述符空间和表单是独立的，这两个“3”可能**指向两个完全不同的文件或资源**

- 父子进程是两个不同的进程
  - 在创建时会共享一些资源，如文件描述符表单
  - 但在创建之后，由于分属于不同的进程，所以他们的文件描述符和表单不再同步和共享（独立的）

> 所以：
>
> 子进程关闭文件描述符3，**并不会影响**父进程的文件描述符3
>
> 如果父子进程都没有对描述3进行操作，则子进程往描述符3对应的文件里写东西，父进程读取描述符3对应的文件仍可能看到子进程写的东西

---

## Shell与命令的运行

- 输入ls时，（实际的意义是我要求Shell运行名为ls的程序，文件系统中会有**一个文件名为ls**），是在要求Shell运行位于文件ls内的这些计算机指令。
- 在Shell中输入指令时【如ls】，Shell通过fork创建一个进程，并用exec来加载名为ls的文件中的指令。

---

## exec系统调用

- exec系统调用会保留当前的文件描述符表单。
  - 所以任何在exec系统调用之前的文件描述符，例如0，1，2等。它们在新的程序中表示相同的东西。
- exec系统调用不会返回，因为exec会**完全替换当前进程的内存**，相当于当前进程不复存在了
  - 所以，先fork拷贝整个父进程，再exec，将整个拷贝丢弃，并用将要运行的文件来替换拷贝好的内存，，，这属实有些浪费

---

## 父子进程

- 无法让子进程等待父进程
  - 因为**wait**系统调用只能**等待当前进程的子进程**
  - 且：`wait()` 是**有一个子进程结束就返回**，它不会等待所有子进程都结束。每次 `wait()` 调用只会处理一个子进程的结束 ---> 如果要等待所有子进程结束，父进程需要多次调用wait
- 子进程拷贝父进程的所有内存，这里的**内存指的是**：
  - 在编译之后，C程序看作是一些在内存中的**指令**，这些**指令像数据一样存在于内存中**，而字节数据可以被拷贝。
  - 将父进程的内存镜像拷贝给子进程，并在子进程中执行。

---

2023.11.5



